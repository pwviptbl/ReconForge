#!/usr/bin/env python3
"""
Buscador de Exploits em Python
Substituto para Searchsploit - Buscador de exploits eficiente em Python puro
"""

import requests
import re
import json
import time
from typing import List, Dict, Optional, Set
from datetime import datetime
from urllib.parse import quote
import os

from utils.logger import obter_logger


class BuscadorExploitsPython:
    """Buscador de exploits eficiente em Python puro"""

    def __init__(self):
        self.logger = obter_logger("ExploitSearch")
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        self.timeout = 10

        # Fontes de exploits
        self.fontes = {
            'exploit_db': {
                'url': 'https://www.exploit-db.com/search',
                'params': {'q': '', 'type': 'remote'},
                'parser': self._parse_exploit_db
            },
            'packet_storm': {
                'url': 'https://packetstormsecurity.com/search/',
                'params': {'q': '', 's': 'files'},
                'parser': self._parse_packet_storm
            },
            'cve_details': {
                'url': 'https://www.cvedetails.com/vulnerability-search.php',
                'params': {'q': '', 'sa': '1'},
                'parser': self._parse_cve_details
            }
        }

        # Cache de resultados
        self.cache_resultados = {}
        self.cache_ttl = 3600  # 1 hora

    def buscar_exploits(self, termo_busca: str, fontes: Optional[List[str]] = None,
                        tipo: Optional[str] = None, plataforma: Optional[str] = None) -> Dict:
        """
        Busca exploits por termo de busca

        Args:
            termo_busca: Termo para buscar exploits
            fontes: Lista de fontes espec√≠ficas (opcional)
            tipo: Tipo de exploit (remote, local, dos, etc.)
            plataforma: Plataforma espec√≠fica (windows, linux, etc.)

        Returns:
            Dict com resultados da busca
        """
        self.logger.info(f"üîç Buscando exploits para: {termo_busca}")

        inicio = time.time()

        # Verificar cache
        cache_key = f"{termo_busca}_{tipo}_{plataforma}"
        if cache_key in self.cache_resultados:
            cached_time, cached_result = self.cache_resultados[cache_key]
            if time.time() - cached_time < self.cache_ttl:
                self.logger.info("üìã Usando resultados em cache")
                return cached_result

        try:
            # Preparar fontes
            fontes_buscar = fontes if fontes else list(self.fontes.keys())

            # Resultados consolidados
            resultados_consolidados = {
                'termo_busca': termo_busca,
                'tipo': tipo,
                'plataforma': plataforma,
                'fontes_buscadas': fontes_buscar,
                'exploits_encontrados': [],
                'estatisticas': {},
                'timestamp': datetime.now().isoformat()
            }

            # Buscar em cada fonte
            for fonte_nome in fontes_buscar:
                if fonte_nome in self.fontes:
                    self.logger.debug(f"üîÑ Buscando em {fonte_nome}...")
                    exploits = self._buscar_fonte(fonte_nome, termo_busca, tipo, plataforma)
                    resultados_consolidados['exploits_encontrados'].extend(exploits)

            # Remover duplicatas
            self._remover_duplicatas(resultados_consolidados)

            # Analisar resultados
            self._analisar_resultados(resultados_consolidados)

            # Salvar no cache
            self.cache_resultados[cache_key] = (time.time(), resultados_consolidados)

            duracao = time.time() - inicio
            resultados_consolidados['duracao_segundos'] = round(duracao, 2)

            self.logger.info(f"‚úÖ Busca conclu√≠da: {len(resultados_consolidados['exploits_encontrados'])} exploits encontrados")
            return resultados_consolidados

        except Exception as e:
            self.logger.error(f"‚ùå Erro na busca: {e}")
            return {
                'termo_busca': termo_busca,
                'erro': str(e),
                'timestamp': datetime.now().isoformat()
            }

    def _buscar_fonte(self, fonte_nome: str, termo: str, tipo: Optional[str] = None,
                     plataforma: Optional[str] = None) -> List[Dict]:
        """Busca exploits em uma fonte espec√≠fica"""
        fonte_config = self.fontes[fonte_nome]
        exploits = []

        try:
            # Preparar par√¢metros
            params = fonte_config['params'].copy()
            params['q'] = termo

            if tipo and fonte_nome == 'exploit_db':
                params['type'] = tipo

            # Fazer requisi√ß√£o
            response = self.session.get(fonte_config['url'], params=params,
                                      timeout=self.timeout, verify=False)

            if response.status_code == 200:
                # Parsear resultados
                parser_func = fonte_config['parser']
                exploits = parser_func(response.text, fonte_nome)

                # Filtrar por plataforma se especificada
                if plataforma:
                    exploits = [e for e in exploits if plataforma.lower() in e.get('plataforma', '').lower()]

            else:
                self.logger.warning(f"‚ö†Ô∏è Erro HTTP {response.status_code} em {fonte_nome}")

        except Exception as e:
            self.logger.error(f"‚ùå Erro ao buscar em {fonte_nome}: {e}")

        return exploits

    def _parse_exploit_db(self, html: str, fonte: str) -> List[Dict]:
        """Parseia resultados do Exploit-DB"""
        exploits = []

        # Regex para extrair informa√ß√µes dos exploits
        pattern = r'<td[^>]*><a[^>]*href="([^"]*exploit[^"]*)"[^>]*>([^<]*)</a></td>.*?<td[^>]*>([^<]*)</td>.*?<td[^>]*>([^<]*)</td>.*?<td[^>]*>([^<]*)</td>'

        matches = re.findall(pattern, html, re.DOTALL | re.IGNORECASE)

        for match in matches:
            try:
                url, titulo, tipo, plataforma, data = match

                exploit = {
                    'titulo': titulo.strip(),
                    'url': f"https://www.exploit-db.com{url}",
                    'tipo': tipo.strip(),
                    'plataforma': plataforma.strip(),
                    'data': data.strip(),
                    'fonte': fonte,
                    'cve': self._extrair_cve(titulo),
                    'severidade': self._avaliar_severidade(titulo, tipo)
                }

                exploits.append(exploit)

            except Exception as e:
                self.logger.debug(f"Erro ao parsear exploit: {e}")

        return exploits

    def _parse_packet_storm(self, html: str, fonte: str) -> List[Dict]:
        """Parseia resultados do Packet Storm"""
        exploits = []

        # Regex para extrair informa√ß√µes
        pattern = r'<a[^>]*href="(/files/[^"]*)"[^>]*>([^<]*)</a>.*?<span[^>]*class="datetime"[^>]*>([^<]*)</span>'

        matches = re.findall(pattern, html, re.DOTALL | re.IGNORECASE)

        for match in matches:
            try:
                url, titulo, data = match

                exploit = {
                    'titulo': titulo.strip(),
                    'url': f"https://packetstormsecurity.com{url}",
                    'tipo': 'unknown',
                    'plataforma': 'unknown',
                    'data': data.strip(),
                    'fonte': fonte,
                    'cve': self._extrair_cve(titulo),
                    'severidade': self._avaliar_severidade(titulo, 'unknown')
                }

                exploits.append(exploit)

            except Exception as e:
                self.logger.debug(f"Erro ao parsear exploit: {e}")

        return exploits

    def _parse_cve_details(self, html: str, fonte: str) -> List[Dict]:
        """Parseia resultados do CVE Details"""
        exploits = []

        # Regex para extrair informa√ß√µes de CVEs
        pattern = r'<td[^>]*><a[^>]*href="(/cve/[^"]*)"[^>]*>(CVE-[^<]*)</a></td>.*?<td[^>]*>([^<]*)</td>.*?<td[^>]*>([^<]*)</td>'

        matches = re.findall(pattern, html, re.DOTALL | re.IGNORECASE)

        for match in matches:
            try:
                url, cve, severidade, data = match

                exploit = {
                    'titulo': f"Exploit for {cve}",
                    'url': f"https://www.cvedetails.com{url}",
                    'tipo': 'cve',
                    'plataforma': 'unknown',
                    'data': data.strip(),
                    'fonte': fonte,
                    'cve': cve,
                    'severidade': severidade.strip()
                }

                exploits.append(exploit)

            except Exception as e:
                self.logger.debug(f"Erro ao parsear CVE: {e}")

        return exploits

    def _extrair_cve(self, texto: str) -> Optional[str]:
        """Extrai CVE do texto"""
        match = re.search(r'(CVE-\d{4}-\d{4,})', texto, re.IGNORECASE)
        return match.group(1) if match else None

    def _avaliar_severidade(self, titulo: str, tipo: str) -> str:
        """Avalia severidade do exploit baseada no t√≠tulo e tipo"""
        titulo_lower = titulo.lower()
        tipo_lower = tipo.lower()

        # Palavras-chave de alta severidade
        alta_severidade = ['rce', 'remote code execution', 'arbitrary code',
                          'buffer overflow', 'privilege escalation', 'root',
                          'admin', 'system', 'critical']

        # Palavras-chave de m√©dia severidade
        media_severidade = ['xss', 'sql injection', 'lfi', 'rfi', 'xxe',
                           'csrf', 'ssrf', 'dos', 'ddos']

        if any(word in titulo_lower or word in tipo_lower for word in alta_severidade):
            return 'alta'
        elif any(word in titulo_lower or word in tipo_lower for word in media_severidade):
            return 'media'
        else:
            return 'baixa'

    def _remover_duplicatas(self, resultados: Dict):
        """Remove exploits duplicados"""
        exploits = resultados['exploits_encontrados']
        unicos = []

        urls_vistas = set()
        cves_vistas = set()

        for exploit in exploits:
            url = exploit.get('url', '')
            cve = exploit.get('cve', '')

            # Verificar duplicata por URL ou CVE
            if url and url not in urls_vistas:
                unicos.append(exploit)
                urls_vistas.add(url)
            elif cve and cve not in cves_vistas:
                unicos.append(exploit)
                cves_vistas.add(cve)

        resultados['exploits_encontrados'] = unicos

    def _analisar_resultados(self, resultados: Dict):
        """Analisa resultados da busca"""
        exploits = resultados['exploits_encontrados']

        # Estat√≠sticas
        fontes = {}
        tipos = {}
        plataformas = {}
        severidades = {}
        anos = {}

        for exploit in exploits:
            # Contar por fonte
            fonte = exploit.get('fonte', 'unknown')
            fontes[fonte] = fontes.get(fonte, 0) + 1

            # Contar por tipo
            tipo = exploit.get('tipo', 'unknown')
            tipos[tipo] = tipos.get(tipo, 0) + 1

            # Contar por plataforma
            plataforma = exploit.get('plataforma', 'unknown')
            plataformas[plataforma] = plataformas.get(plataforma, 0) + 1

            # Contar por severidade
            severidade = exploit.get('severidade', 'unknown')
            severidades[severidade] = severidades.get(severidade, 0) + 1

            # Contar por ano
            data = exploit.get('data', '')
            if data:
                try:
                    ano = data.split('-')[0] if '-' in data else data[-4:]
                    if ano.isdigit():
                        anos[ano] = anos.get(ano, 0) + 1
                except:
                    pass

        resultados['estatisticas'] = {
            'total_exploits': len(exploits),
            'por_fonte': fontes,
            'por_tipo': tipos,
            'por_plataforma': plataformas,
            'por_severidade': severidades,
            'por_ano': anos
        }

    def buscar_por_cve(self, cve: str) -> Dict:
        """Busca exploits espec√≠ficos para uma CVE"""
        return self.buscar_exploits(cve, tipo='cve')

    def buscar_por_servico(self, servico: str, versao: Optional[str] = None) -> Dict:
        """Busca exploits para um servi√ßo espec√≠fico"""
        termo = f"{servico} {versao}" if versao else servico
        return self.buscar_exploits(termo)

    def salvar_resultados(self, resultado: Dict, formato: str = 'json', arquivo: str = None):
        """Salva resultados da busca em arquivo"""
        if not arquivo:
            termo = resultado['termo_busca'].replace(' ', '_')
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            arquivo = f"exploits_{termo}_{timestamp}.{formato}"

        if formato == 'json':
            with open(arquivo, 'w', encoding='utf-8') as f:
                json.dump(resultado, f, indent=2, ensure_ascii=False)

        elif formato == 'txt':
            with open(arquivo, 'w', encoding='utf-8') as f:
                f.write(f"Busca de Exploits - {resultado['termo_busca']}\\n")
                f.write(f"Total encontrado: {len(resultado['exploits_encontrados'])}\\n")
                f.write(f"Data: {resultado['timestamp']}\\n\\n")

                if resultado['exploits_encontrados']:
                    f.write("EXPLOITS ENCONTRADOS:\\n")
                    for exploit in resultado['exploits_encontrados']:
                        severidade_emoji = "üî¥" if exploit.get('severidade') == 'alta' else "üü°" if exploit.get('severidade') == 'media' else "üü¢"
                        f.write(f"{severidade_emoji} [{exploit.get('fonte', 'unknown')}] {exploit['titulo']}\\n")
                        f.write(f"    URL: {exploit['url']}\\n")
                        if exploit.get('cve'):
                            f.write(f"    CVE: {exploit['cve']}\\n")
                        if exploit.get('tipo'):
                            f.write(f"    Tipo: {exploit['tipo']}\\n")
                        if exploit.get('plataforma'):
                            f.write(f"    Plataforma: {exploit['plataforma']}\\n")
                        f.write("\\n")

        self.logger.info(f"üíæ Resultados salvos em: {arquivo}")


# Fun√ß√µes de compatibilidade
def buscar_exploits(termo: str) -> Dict:
    """Fun√ß√£o de compatibilidade para busca b√°sica"""
    buscador = BuscadorExploitsPython()
    return buscador.buscar_exploits(termo)

def buscar_por_cve(cve: str) -> Dict:
    """Fun√ß√£o de compatibilidade para busca por CVE"""
    buscador = BuscadorExploitsPython()
    return buscador.buscar_por_cve(cve)


if __name__ == "__main__":
    # Teste do buscador
    buscador = BuscadorExploitsPython()

    # Teste com termo de busca
    termo_teste = "apache 2.4"

    print(f"üîç Testando busca de exploits para: {termo_teste}")
    resultado = buscador.buscar_exploits(termo_teste)

    if 'erro' not in resultado:
        print(f"‚úÖ Busca conclu√≠da: {len(resultado['exploits_encontrados'])} exploits encontrados")
        print("\\nüìã Alguns resultados:")

        for exploit in resultado['exploits_encontrados'][:5]:
            severidade_emoji = "üî¥" if exploit.get('severidade') == 'alta' else "üü°" if exploit.get('severidade') == 'media' else "üü¢"
            print(f"  {severidade_emoji} {exploit['titulo']}")
            if exploit.get('cve'):
                print(f"    CVE: {exploit['cve']}")
            print(f"    Fonte: {exploit.get('fonte', 'unknown')}")
            print()
    else:
        print(f"‚ùå Erro: {resultado['erro']}")
