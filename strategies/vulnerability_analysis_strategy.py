#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Estratégia de Análise de Vulnerabilidades - Fase 2 da Refatoração

Integra múltiplos módulos de detecção de vulnerabilidades:
- Scanner de vulnerabilidades web
- Análise de CVEs
- Testes de penetração automatizados
- Validação de configurações de segurança
"""

from typing import Dict, Any, List, Optional, Set
from datetime import datetime
import re
import json

from interfaces.scanner_strategy import (
    IVulnerabilityAnalysisStrategy, StrategyPriority, ExecutionPhase, StrategyResult, BaseStrategy
)
from core.scan_context import ScanContext, ServiceInfo


class VulnerabilityAnalysisStrategy(BaseStrategy, IVulnerabilityAnalysisStrategy):
    """Estratégia de análise de vulnerabilidades usando múltiplos scanners"""
    
    def __init__(self, vuln_scanner_module=None, cve_scanner_module=None, 
                 web_vuln_module=None, config_checker_module=None, logger=None):
        super().__init__(logger)
        self._vuln_scanner = vuln_scanner_module
        self._cve_scanner = cve_scanner_module
        self._web_vuln_module = web_vuln_module
        self._config_checker = config_checker_module
        
        # Categorias de vulnerabilidades
        self._vulnerability_categories = {
            'web': ['xss', 'sqli', 'csrf', 'lfi', 'rfi', 'ssrf', 'xxe'],
            'network': ['open_ports', 'weak_protocols', 'unencrypted_services'],
            'system': ['outdated_software', 'misconfigurations', 'weak_passwords'],
            'application': ['code_injection', 'path_traversal', 'information_disclosure']
        }
        
        # Mapeamento de severidade
        self._severity_mapping = {
            'critical': 5,
            'high': 4,
            'medium': 3,
            'low': 2,
            'info': 1
        }
        
        # Cache de resultados
        self._vulnerability_cache = {}
    
    @property
    def name(self) -> str:
        return "vulnerability_analysis"
    
    @property
    def description(self) -> str:
        return "Análise abrangente de vulnerabilidades usando múltiplos scanners e bases de CVE"
    
    @property
    def priority(self) -> StrategyPriority:
        return StrategyPriority.HIGH
    
    @property
    def execution_phase(self) -> ExecutionPhase:
        return ExecutionPhase.VULNERABILITY_ANALYSIS
    
    def can_execute(self, context: ScanContext) -> bool:
        """
        Pode executar se:
        - Há serviços identificados
        - Há tecnologias detectadas
        - Ainda não foi executada para todos os alvos
        """
        # Verificar se há alvos válidos para análise
        has_services = any(context.services.values())
        has_open_ports = any(context.open_ports.values())
        has_technologies = bool(context.user_preferences.get('detected_technologies', {}))
        
        return has_services or has_open_ports or has_technologies
    
    def execute(self, target: str, context: ScanContext) -> StrategyResult:
        """
        Executa análise de vulnerabilidades no alvo especificado
        
        Args:
            target: Host ou URL a analisar
            context: Contexto do scan
            
        Returns:
            Resultado com vulnerabilidades encontradas
        """
        self._start_execution_timer()
        self._log("INFO", f"Iniciando análise de vulnerabilidades para: {target}")
        
        # Determinar escopo da análise
        analysis_scope = self._determine_analysis_scope(target, context)
        
        if not analysis_scope['valid']:
            return self._create_result(
                success=False,
                warnings=[f"Escopo de análise inválido para {target}"]
            )
        
        # Executar análises de vulnerabilidades
        all_vulnerabilities = []
        analysis_summary = {
            'web_scan': False,
            'network_scan': False,
            'cve_analysis': False,
            'config_check': False
        }
        errors = []
        warnings = []
        
        # 1. Análise de vulnerabilidades web
        if analysis_scope['web_targets']:
            try:
                web_vulns = self._analyze_web_vulnerabilities(analysis_scope['web_targets'], context)
                all_vulnerabilities.extend(web_vulns['vulnerabilities'])
                analysis_summary['web_scan'] = web_vulns['success']
                if web_vulns['errors']:
                    errors.extend(web_vulns['errors'])
                if web_vulns['warnings']:
                    warnings.extend(web_vulns['warnings'])
            except Exception as e:
                error_msg = f"Erro na análise web: {e}"
                errors.append(error_msg)
                self._log("ERROR", error_msg)
        
        # 2. Análise de vulnerabilidades de rede
        if analysis_scope['network_targets']:
            try:
                network_vulns = self._analyze_network_vulnerabilities(analysis_scope['network_targets'], context)
                all_vulnerabilities.extend(network_vulns['vulnerabilities'])
                analysis_summary['network_scan'] = network_vulns['success']
                if network_vulns['errors']:
                    errors.extend(network_vulns['errors'])
                if network_vulns['warnings']:
                    warnings.extend(network_vulns['warnings'])
            except Exception as e:
                error_msg = f"Erro na análise de rede: {e}"
                errors.append(error_msg)
                self._log("ERROR", error_msg)
        
        # 3. Análise de CVEs
        if analysis_scope['cve_targets']:
            try:
                cve_vulns = self._analyze_cve_vulnerabilities(analysis_scope['cve_targets'], context)
                all_vulnerabilities.extend(cve_vulns['vulnerabilities'])
                analysis_summary['cve_analysis'] = cve_vulns['success']
                if cve_vulns['errors']:
                    errors.extend(cve_vulns['errors'])
                if cve_vulns['warnings']:
                    warnings.extend(cve_vulns['warnings'])
            except Exception as e:
                error_msg = f"Erro na análise de CVE: {e}"
                errors.append(error_msg)
                self._log("ERROR", error_msg)
        
        # 4. Verificação de configurações
        if analysis_scope['config_targets']:
            try:
                config_vulns = self._analyze_configuration_vulnerabilities(analysis_scope['config_targets'], context)
                all_vulnerabilities.extend(config_vulns['vulnerabilities'])
                analysis_summary['config_check'] = config_vulns['success']
                if config_vulns['errors']:
                    errors.extend(config_vulns['errors'])
                if config_vulns['warnings']:
                    warnings.extend(config_vulns['warnings'])
            except Exception as e:
                error_msg = f"Erro na verificação de configurações: {e}"
                errors.append(error_msg)
                self._log("ERROR", error_msg)
        
        # Processar e consolidar resultados
        return self._process_vulnerability_results(all_vulnerabilities, analysis_summary, 
                                                 errors, warnings, context)
    
    def analyze_vulnerabilities(self, target: str, vulnerability_types: List[str], 
                               context: ScanContext) -> StrategyResult:
        """Implementação específica da interface IVulnerabilityAnalysisStrategy"""
        # Filtrar escopo baseado nos tipos solicitados
        original_preferences = context.user_preferences.copy()
        context.user_preferences['requested_vuln_types'] = vulnerability_types
        
        result = self.execute(target, context)
        
        # Restaurar preferências originais
        context.user_preferences = original_preferences
        
        return result
    
    def analyze_vulnerabilities(self, target: str, services: Dict[str, Any], 
                               context: ScanContext) -> StrategyResult:
        """Implementação do método abstrato da interface IVulnerabilityAnalysisStrategy"""
        # Adicionar serviços ao contexto se fornecidos
        if services:
            context.user_preferences['provided_services'] = services
        
        return self.execute(target, context)
    
    def get_dependencies(self) -> List[str]:
        """Depende de detecção de serviços e tecnologias para análise efetiva"""
        return ["service_detection", "technology_detection"]
    
    def estimate_execution_time(self, target: str, context: ScanContext) -> float:
        """
        Estima tempo baseado no escopo de análise
        
        Args:
            target: Alvo a analisar
            context: Contexto atual
            
        Returns:
            Tempo estimado em segundos
        """
        scope = self._determine_analysis_scope(target, context)
        
        if not scope['valid']:
            return 10.0
        
        # Estimativas por tipo de análise
        time_estimates = {
            'web_targets': len(scope.get('web_targets', [])) * 120,  # 2 min por URL
            'network_targets': len(scope.get('network_targets', [])) * 60,  # 1 min por host
            'cve_targets': len(scope.get('cve_targets', [])) * 30,  # 30s por serviço
            'config_targets': len(scope.get('config_targets', [])) * 45  # 45s por alvo
        }
        
        total_time = sum(time_estimates.values())
        return min(total_time, 1800.0)  # Máximo 30 minutos
    
    def validate_target(self, target: str) -> bool:
        """Valida se o alvo pode ser analisado para vulnerabilidades"""
        if not target or not isinstance(target, str):
            return False
        
        # URLs e hosts são válidos
        return (target.startswith(('http://', 'https://')) or 
                self._is_valid_host(target))
    
    def get_required_tools(self) -> List[str]:
        """Ferramentas recomendadas para análise completa"""
        return ["nmap", "nikto", "sqlmap", "nuclei", "wpscan"]
    
    def get_output_artifacts(self) -> List[str]:
        """Produz relatórios de vulnerabilidades"""
        return ["vulnerability_report", "cve_analysis", "security_recommendations"]
    
    def supports_parallel_execution(self) -> bool:
        """Análise de vulnerabilidades pode ser intensiva, melhor sequencial"""
        return False
    
    # Métodos privados
    
    def _determine_analysis_scope(self, target: str, context: ScanContext) -> Dict[str, Any]:
        """Determina o escopo completo da análise de vulnerabilidades"""
        scope = {
            'valid': False,
            'web_targets': [],
            'network_targets': [],
            'cve_targets': [],
            'config_targets': []
        }
        
        # Extrair host principal
        if target.startswith(('http://', 'https://')):
            import urllib.parse
            parsed = urllib.parse.urlparse(target)
            main_host = parsed.hostname
            scope['web_targets'].append(target)
        else:
            main_host = target
        
        # Adicionar alvos web baseado em serviços
        if main_host in context.services:
            for service in context.services[main_host]:
                if 'http' in service.service_name.lower():
                    protocol = 'https' if service.port == 443 or 'https' in service.service_name.lower() else 'http'
                    port_suffix = f":{service.port}" if service.port not in [80, 443] else ""
                    web_url = f"{protocol}://{main_host}{port_suffix}"
                    if web_url not in scope['web_targets']:
                        scope['web_targets'].append(web_url)
        
        # Adicionar alvos de rede
        scope['network_targets'].append(main_host)
        
        # Adicionar alvos para análise de CVE baseado em tecnologias detectadas
        detected_techs = context.user_preferences.get('detected_technologies', {})
        if detected_techs:
            for url, technologies in detected_techs.items():
                for category, techs in technologies.items():
                    for tech_name, tech_info in techs.items():
                        cve_target = {
                            'host': main_host,
                            'technology': tech_name,
                            'version': tech_info.get('version', ''),
                            'category': category
                        }
                        if cve_target not in scope['cve_targets']:
                            scope['cve_targets'].append(cve_target)
        
        # Adicionar alvos para verificação de configuração
        scope['config_targets'] = scope['web_targets'] + scope['network_targets']
        
        scope['valid'] = bool(scope['web_targets'] or scope['network_targets'] or 
                             scope['cve_targets'] or scope['config_targets'])
        
        return scope
    
    def _analyze_web_vulnerabilities(self, web_targets: List[str], context: ScanContext) -> Dict[str, Any]:
        """Analisa vulnerabilidades web usando scanners especializados"""
        vulnerabilities = []
        success = False
        errors = []
        warnings = []
        
        for target_url in web_targets:
            try:
                # Scanner web principal
                if self._web_vuln_module:
                    try:
                        web_result = self._execute_web_scanner(target_url, context)
                        if web_result['success']:
                            vulnerabilities.extend(web_result['vulnerabilities'])
                            success = True
                        else:
                            warnings.extend(web_result.get('warnings', []))
                    except Exception as e:
                        warnings.append(f"Scanner web falhou para {target_url}: {e}")
                
                # Scanner de vulnerabilidades genérico
                if self._vuln_scanner:
                    try:
                        vuln_result = self._execute_vulnerability_scanner(target_url, context)
                        if vuln_result['success']:
                            vulnerabilities.extend(vuln_result['vulnerabilities'])
                            success = True
                        else:
                            warnings.extend(vuln_result.get('warnings', []))
                    except Exception as e:
                        warnings.append(f"Scanner de vulnerabilidades falhou para {target_url}: {e}")
                
            except Exception as e:
                error_msg = f"Erro ao analisar {target_url}: {e}"
                errors.append(error_msg)
                self._log("ERROR", error_msg)
        
        return {
            'vulnerabilities': vulnerabilities,
            'success': success,
            'errors': errors,
            'warnings': warnings
        }
    
    def _analyze_network_vulnerabilities(self, network_targets: List[str], context: ScanContext) -> Dict[str, Any]:
        """Analisa vulnerabilidades de rede"""
        vulnerabilities = []
        success = False
        errors = []
        warnings = []
        
        for target_host in network_targets:
            try:
                # Análise de portas e serviços vulneráveis
                network_vulns = self._analyze_network_services(target_host, context)
                vulnerabilities.extend(network_vulns)
                
                if network_vulns:
                    success = True
                
            except Exception as e:
                error_msg = f"Erro na análise de rede para {target_host}: {e}"
                errors.append(error_msg)
                self._log("ERROR", error_msg)
        
        return {
            'vulnerabilities': vulnerabilities,
            'success': success,
            'errors': errors,
            'warnings': warnings
        }
    
    def _analyze_cve_vulnerabilities(self, cve_targets: List[Dict], context: ScanContext) -> Dict[str, Any]:
        """Analisa vulnerabilidades baseadas em CVEs conhecidos"""
        vulnerabilities = []
        success = False
        errors = []
        warnings = []
        
        if not self._cve_scanner:
            warnings.append("Scanner de CVE não disponível")
            return {
                'vulnerabilities': vulnerabilities,
                'success': success,
                'errors': errors,
                'warnings': warnings
            }
        
        for cve_target in cve_targets:
            try:
                cve_result = self._search_cves_for_technology(cve_target)
                if cve_result['success']:
                    vulnerabilities.extend(cve_result['vulnerabilities'])
                    success = True
                else:
                    warnings.extend(cve_result.get('warnings', []))
                    
            except Exception as e:
                error_msg = f"Erro na análise de CVE para {cve_target}: {e}"
                errors.append(error_msg)
                self._log("ERROR", error_msg)
        
        return {
            'vulnerabilities': vulnerabilities,
            'success': success,
            'errors': errors,
            'warnings': warnings
        }
    
    def _analyze_configuration_vulnerabilities(self, config_targets: List[str], context: ScanContext) -> Dict[str, Any]:
        """Analisa vulnerabilidades de configuração"""
        vulnerabilities = []
        success = False
        errors = []
        warnings = []
        
        if not self._config_checker:
            warnings.append("Verificador de configurações não disponível")
            return {
                'vulnerabilities': vulnerabilities,
                'success': success,
                'errors': errors,
                'warnings': warnings
            }
        
        for target in config_targets:
            try:
                config_result = self._check_security_configurations(target, context)
                if config_result['success']:
                    vulnerabilities.extend(config_result['vulnerabilities'])
                    success = True
                else:
                    warnings.extend(config_result.get('warnings', []))
                    
            except Exception as e:
                error_msg = f"Erro na verificação de configurações para {target}: {e}"
                errors.append(error_msg)
                self._log("ERROR", error_msg)
        
        return {
            'vulnerabilities': vulnerabilities,
            'success': success,
            'errors': errors,
            'warnings': warnings
        }
    
    def _execute_web_scanner(self, url: str, context: ScanContext) -> Dict[str, Any]:
        """Executa scanner web específico"""
        try:
            if hasattr(self._web_vuln_module, 'scan_completo'):
                result = self._web_vuln_module.scan_completo(url)
            elif hasattr(self._web_vuln_module, 'executar'):
                result = self._web_vuln_module.executar(url)
            else:
                return {'success': False, 'warnings': ['Scanner web sem método conhecido']}
            
            if isinstance(result, dict) and 'vulnerabilidades' in result:
                vulns = result['vulnerabilidades']
                formatted_vulns = []
                
                for vuln in vulns:
                    formatted_vuln = self._format_vulnerability(vuln, 'web', url)
                    formatted_vulns.append(formatted_vuln)
                
                return {
                    'success': True,
                    'vulnerabilities': formatted_vulns
                }
            else:
                return {
                    'success': False,
                    'warnings': [f"Scanner web retornou formato inesperado: {result}"]
                }
                
        except Exception as e:
            return {
                'success': False,
                'warnings': [f"Erro no scanner web: {e}"]
            }
    
    def _execute_vulnerability_scanner(self, target: str, context: ScanContext) -> Dict[str, Any]:
        """Executa scanner de vulnerabilidades genérico"""
        try:
            if hasattr(self._vuln_scanner, 'scan_target'):
                result = self._vuln_scanner.scan_target(target)
            elif hasattr(self._vuln_scanner, 'executar'):
                result = self._vuln_scanner.executar(target)
            else:
                return {'success': False, 'warnings': ['Scanner de vulnerabilidades sem método conhecido']}
            
            if isinstance(result, dict) and result.get('sucesso'):
                vulns = result.get('dados', {}).get('vulnerabilidades', [])
                formatted_vulns = []
                
                for vuln in vulns:
                    formatted_vuln = self._format_vulnerability(vuln, 'generic', target)
                    formatted_vulns.append(formatted_vuln)
                
                return {
                    'success': True,
                    'vulnerabilities': formatted_vulns
                }
            else:
                return {
                    'success': False,
                    'warnings': [f"Scanner genérico retornou: {result}"]
                }
                
        except Exception as e:
            return {
                'success': False,
                'warnings': [f"Erro no scanner genérico: {e}"]
            }
    
    def _analyze_network_services(self, host: str, context: ScanContext) -> List[Dict[str, Any]]:
        """Analisa serviços de rede para vulnerabilidades conhecidas"""
        vulnerabilities = []
        
        if host not in context.services:
            return vulnerabilities
        
        for service in context.services[host]:
            # Verificar portas/protocolos inseguros
            insecure_services = {
                21: "FTP sem criptografia",
                23: "Telnet sem criptografia", 
                25: "SMTP sem criptografia",
                53: "DNS recursivo aberto",
                80: "HTTP sem HTTPS",
                110: "POP3 sem criptografia",
                143: "IMAP sem criptografia",
                161: "SNMP com comunidade padrão",
                445: "SMB exposto",
                1433: "SQL Server exposto",
                3306: "MySQL exposto",
                5432: "PostgreSQL exposto"
            }
            
            if service.port in insecure_services:
                vuln = {
                    'id': f"insecure_service_{service.port}",
                    'name': f"Serviço Inseguro na Porta {service.port}",
                    'description': insecure_services[service.port],
                    'severity': 'medium',
                    'category': 'network',
                    'target': f"{host}:{service.port}",
                    'port': service.port,
                    'service': service.service_name,
                    'confidence': 0.8,
                    'references': [],
                    'recommendation': f"Considere usar versão segura do serviço ou restringir acesso"
                }
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _search_cves_for_technology(self, cve_target: Dict) -> Dict[str, Any]:
        """Busca CVEs para uma tecnologia específica"""
        try:
            technology = cve_target['technology']
            version = cve_target.get('version', '')
            
            if hasattr(self._cve_scanner, 'search_cves'):
                result = self._cve_scanner.search_cves(technology, version)
            elif hasattr(self._cve_scanner, 'buscar_cves'):
                result = self._cve_scanner.buscar_cves(technology, version)
            else:
                return {'success': False, 'warnings': ['Scanner CVE sem método conhecido']}
            
            if isinstance(result, dict) and result.get('cves'):
                vulnerabilities = []
                
                for cve in result['cves']:
                    vuln = self._format_cve_vulnerability(cve, cve_target)
                    vulnerabilities.append(vuln)
                
                return {
                    'success': True,
                    'vulnerabilities': vulnerabilities
                }
            else:
                return {
                    'success': False,
                    'warnings': [f"Nenhum CVE encontrado para {technology} {version}"]
                }
                
        except Exception as e:
            return {
                'success': False,
                'warnings': [f"Erro na busca de CVEs: {e}"]
            }
    
    def _check_security_configurations(self, target: str, context: ScanContext) -> Dict[str, Any]:
        """Verifica configurações de segurança"""
        try:
            if hasattr(self._config_checker, 'check_security'):
                result = self._config_checker.check_security(target)
            elif hasattr(self._config_checker, 'verificar_configuracoes'):
                result = self._config_checker.verificar_configuracoes(target)
            else:
                return {'success': False, 'warnings': ['Verificador de configurações sem método conhecido']}
            
            if isinstance(result, dict) and result.get('issues'):
                vulnerabilities = []
                
                for issue in result['issues']:
                    vuln = self._format_configuration_vulnerability(issue, target)
                    vulnerabilities.append(vuln)
                
                return {
                    'success': True,
                    'vulnerabilities': vulnerabilities
                }
            else:
                return {
                    'success': False,
                    'warnings': [f"Nenhum problema de configuração encontrado em {target}"]
                }
                
        except Exception as e:
            return {
                'success': False,
                'warnings': [f"Erro na verificação de configurações: {e}"]
            }
    
    def _format_vulnerability(self, vuln: Any, category: str, target: str) -> Dict[str, Any]:
        """Formata vulnerabilidade para formato padrão"""
        if isinstance(vuln, dict):
            return {
                'id': vuln.get('id', f"{category}_vuln_{hash(str(vuln))}"),
                'name': vuln.get('nome', vuln.get('name', 'Vulnerabilidade Detectada')),
                'description': vuln.get('descricao', vuln.get('description', '')),
                'severity': vuln.get('severidade', vuln.get('severity', 'medium')),
                'category': category,
                'target': target,
                'confidence': vuln.get('confianca', vuln.get('confidence', 0.7)),
                'references': vuln.get('referencias', vuln.get('references', [])),
                'recommendation': vuln.get('recomendacao', vuln.get('recommendation', ''))
            }
        else:
            return {
                'id': f"{category}_vuln_{hash(str(vuln))}",
                'name': str(vuln),
                'description': f"Vulnerabilidade detectada: {vuln}",
                'severity': 'medium',
                'category': category,
                'target': target,
                'confidence': 0.6,
                'references': [],
                'recommendation': 'Revisar e corrigir conforme necessário'
            }
    
    def _format_cve_vulnerability(self, cve: Dict, target_info: Dict) -> Dict[str, Any]:
        """Formata vulnerabilidade CVE para formato padrão"""
        return {
            'id': cve.get('cve_id', f"cve_{hash(str(cve))}"),
            'name': f"CVE: {cve.get('cve_id', 'N/A')}",
            'description': cve.get('description', ''),
            'severity': cve.get('severity', 'medium'),
            'category': 'cve',
            'target': target_info['host'],
            'technology': target_info['technology'],
            'version': target_info.get('version', ''),
            'confidence': 0.9,
            'references': cve.get('references', []),
            'cvss_score': cve.get('cvss_score', 0.0),
            'recommendation': 'Atualizar para versão corrigida'
        }
    
    def _format_configuration_vulnerability(self, issue: Dict, target: str) -> Dict[str, Any]:
        """Formata problema de configuração para formato padrão"""
        return {
            'id': issue.get('id', f"config_{hash(str(issue))}"),
            'name': issue.get('name', 'Problema de Configuração'),
            'description': issue.get('description', ''),
            'severity': issue.get('severity', 'low'),
            'category': 'configuration',
            'target': target,
            'confidence': 0.8,
            'references': issue.get('references', []),
            'recommendation': issue.get('fix', 'Corrigir configuração')
        }
    
    def _process_vulnerability_results(self, all_vulnerabilities: List[Dict], 
                                     analysis_summary: Dict, errors: List[str], 
                                     warnings: List[str], context: ScanContext) -> StrategyResult:
        """Processa resultados finais da análise de vulnerabilidades"""
        
        if not all_vulnerabilities:
            return self._create_result(
                success=any(analysis_summary.values()),
                data={
                    "vulnerabilities_found": 0,
                    "analysis_summary": analysis_summary,
                    "scan_complete": True
                },
                warnings=warnings + ["Nenhuma vulnerabilidade encontrada"],
                errors=errors
            )
        
        # Estatísticas de vulnerabilidades
        severity_counts = {}
        category_counts = {}
        
        for vuln in all_vulnerabilities:
            severity = vuln.get('severity', 'unknown')
            category = vuln.get('category', 'unknown')
            
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
            category_counts[category] = category_counts.get(category, 0) + 1
        
        # Calcular score de risco
        risk_score = self._calculate_risk_score(all_vulnerabilities)
        
        # Ordenar vulnerabilidades por severidade
        sorted_vulnerabilities = sorted(
            all_vulnerabilities,
            key=lambda v: self._severity_mapping.get(v.get('severity', 'low'), 1),
            reverse=True
        )
        
        # Adicionar ao contexto
        context.vulnerabilities.extend(sorted_vulnerabilities)
        
        # Sugerir próximas estratégias
        next_strategies = []
        if any(v['category'] == 'web' for v in all_vulnerabilities):
            next_strategies.append("web_exploitation")
        if any(v['category'] == 'network' for v in all_vulnerabilities):
            next_strategies.append("network_exploitation")
        
        return self._create_result(
            success=True,
            data={
                "vulnerabilities_found": len(all_vulnerabilities),
                "severity_distribution": severity_counts,
                "category_distribution": category_counts,
                "risk_score": risk_score,
                "analysis_summary": analysis_summary,
                "scan_complete": True
            },
            vulnerabilities=sorted_vulnerabilities,
            next_strategies=next_strategies,
            confidence_score=0.8 if all_vulnerabilities else 0.3,
            warnings=warnings,
            errors=errors
        )
    
    def _calculate_risk_score(self, vulnerabilities: List[Dict]) -> float:
        """Calcula score de risco baseado nas vulnerabilidades encontradas"""
        if not vulnerabilities:
            return 0.0
        
        total_score = 0.0
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'low')
            confidence = vuln.get('confidence', 0.5)
            
            severity_weight = self._severity_mapping.get(severity, 1)
            vuln_score = severity_weight * confidence
            total_score += vuln_score
        
        # Normalizar para escala 0-10
        max_possible_score = len(vulnerabilities) * 5  # Critical = 5
        normalized_score = min((total_score / max_possible_score) * 10, 10.0)
        
        return round(normalized_score, 2)
    
    def _is_valid_host(self, host: str) -> bool:
        """Valida se é um host válido"""
        if not host or not isinstance(host, str):
            return False
        
        return re.match(r'^[a-zA-Z0-9.-]+$', host) is not None
