"""
Plugin de Busca de Exploits
Busca exploits para versÃµes de software detectadas usando mÃºltiplas fontes
"""

import requests
import time
import re
import json
from typing import Dict, Any, List, Optional, Tuple
from urllib.parse import quote
import subprocess

import sys
from pathlib import Path
sys.path.append(str(Path(__file__).parent.parent))

from core.plugin_base import VulnerabilityPlugin, PluginResult
from core.config import get_config


class ExploitSearcherPlugin(VulnerabilityPlugin):
    """Plugin para busca automatizada de exploits baseada em versÃµes detectadas"""
    
    def __init__(self):
        super().__init__()
        self.description = "Busca exploits para versÃµes de software detectadas via mÃºltiplas fontes"
        self.version = "1.0.0"
        self.requirements = ["requests"]
        self.supported_targets = ["ip", "domain", "url"]
        
        # URLs das APIs
        self.cve_api_url = "https://cve.circl.lu/api/search"
        self.exploit_db_api = "https://www.exploit-db.com/api/v1/search"
        self.nvd_api_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        
        # ConfiguraÃ§Ãµes padrÃ£o
        self.timeout = 10
        self.max_results_per_source = 20
        self.min_cvss_score = 0.0
        self.search_exploitdb = True
        self.search_cve = True
        self.search_nvd = True
        self.search_github = True
        
        # Headers para requisiÃ§Ãµes
        self.headers = {
            'User-Agent': 'ReconForge/1.0 (Security Research Tool)',
            'Accept': 'application/json'
        }
        
        # Cache para evitar requisiÃ§Ãµes duplicadas
        self.cache = {}
    
    def execute(self, target: str, context: Dict[str, Any], **kwargs) -> PluginResult:
        """Executa busca de exploits baseada no contexto"""
        start_time = time.time()
        
        try:
            # Ler configuraÃ§Ãµes do YAML
            self._load_config()
            
            # Extrair informaÃ§Ãµes de versÃµes do contexto
            version_info = self._extract_version_info(context)
            
            if not version_info:
                return PluginResult(
                    success=True,
                    plugin_name=self.name,
                    execution_time=time.time() - start_time,
                    data={
                        'target': target,
                        'message': 'Nenhuma informaÃ§Ã£o de versÃ£o encontrada no contexto',
                        'software_detected': [],
                        'exploits_found': []
                    }
                )
            
            # Buscar exploits para cada software/versÃ£o detectada
            all_exploits = []
            search_results = {}
            
            for software_info in version_info:
                software_name = software_info.get('name', '')
                version = software_info.get('version', '')
                
                if software_name and version != 'unknown':
                    exploits = self._search_exploits_for_software(software_name, version)
                    if exploits:
                        all_exploits.extend(exploits)
                        search_results[f"{software_name} {version}"] = exploits
            
            # Classificar exploits por criticidade
            classified_exploits = self._classify_exploits(all_exploits)
            
            # Gerar relatÃ³rio de exploits
            report = self._generate_exploit_report(classified_exploits, search_results)
            
            execution_time = time.time() - start_time
            
            return PluginResult(
                success=True,
                plugin_name=self.name,
                execution_time=execution_time,
                data={
                    'target': target,
                    'software_analyzed': len(version_info),
                    'software_detected': version_info,
                    'total_exploits_found': len(all_exploits),
                    'exploits_by_severity': classified_exploits,
                    'detailed_results': search_results,
                    'security_report': report,
                    'search_summary': self._generate_search_summary(version_info, all_exploits)
                }
            )
            
        except Exception as e:
            return PluginResult(
                success=False,
                plugin_name=self.name,
                execution_time=time.time() - start_time,
                data={},
                error=str(e)
            )
    
    def validate_target(self, target: str) -> bool:
        """Plugin funciona com qualquer target se houver contexto"""
        return True
    
    def _load_config(self):
        """Carrega configuraÃ§Ãµes do arquivo YAML"""
        self.search_exploitdb = get_config('plugins.config.ExploitSearcherPlugin.search_exploitdb', True)
        self.search_cve = get_config('plugins.config.ExploitSearcherPlugin.search_cve', True)
        self.search_nvd = get_config('plugins.config.ExploitSearcherPlugin.search_nvd', True)
        self.search_github = get_config('plugins.config.ExploitSearcherPlugin.search_github', True)
        self.max_results_per_source = get_config('plugins.config.ExploitSearcherPlugin.max_results_per_source', 20)
        self.min_cvss_score = get_config('plugins.config.ExploitSearcherPlugin.min_cvss_score', 0.0)
        self.timeout = get_config('plugins.config.ExploitSearcherPlugin.timeout', 10)
    
    def _extract_version_info(self, context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extrai informaÃ§Ãµes de versÃµes do contexto de outros plugins"""
        version_info = []
        
        # Buscar em descobertas consolidadas
        discoveries = context.get('discoveries', {})
        services = discoveries.get('services', [])
        for service in services:
            if not isinstance(service, dict):
                continue
            name = service.get('service', 'unknown')
            version = service.get('version', '') or 'unknown'
            product = service.get('product', '')
            if name and version != 'unknown':
                version_info.append({
                    'name': name,
                    'version': version,
                    'product': product,
                    'port': service.get('port'),
                    'source': 'Discoveries'
                })

        technologies = discoveries.get('technologies', [])
        for tech in technologies:
            if isinstance(tech, dict):
                name = tech.get('name') or tech.get('technology') or 'unknown'
                version = tech.get('version', 'unknown')
            else:
                name = str(tech)
                version = 'unknown'
            if name and version != 'unknown':
                version_info.append({
                    'name': name,
                    'version': version,
                    'source': 'Discoveries'
                })
        
        # TechnologyDetectorPlugin results (legado)
        if 'TechnologyDetectorPlugin' in discoveries:
            tech_data = discoveries['TechnologyDetectorPlugin']
            technologies = tech_data.get('technologies', {})
            
            for tech_name, tech_info in technologies.items():
                if isinstance(tech_info, dict):
                    version_info.append({
                        'name': tech_name,
                        'version': tech_info.get('version', 'unknown'),
                        'confidence': tech_info.get('confidence', 'medium'),
                        'source': 'TechnologyDetectorPlugin'
                    })
        
        # NmapScannerPlugin results (legado)
        if 'NmapScannerPlugin' in discoveries:
            nmap_data = discoveries['NmapScannerPlugin']
            services = nmap_data.get('services', [])
            
            for service in services:
                if service.get('version'):
                    version_info.append({
                        'name': service.get('service', 'unknown'),
                        'version': service.get('version', 'unknown'),
                        'product': service.get('product', ''),
                        'port': service.get('port'),
                        'source': 'NmapScannerPlugin'
                    })
        
        # SSLAnalyzerPlugin results
        if 'SSLAnalyzerPlugin' in discoveries:
            ssl_data = discoveries['SSLAnalyzerPlugin']
            supported_protocols = ssl_data.get('ssl_configuration', {}).get('supported_protocols', [])
            
            for protocol in supported_protocols:
                if protocol:
                    version_info.append({
                        'name': 'SSL/TLS',
                        'version': protocol,
                        'source': 'SSLAnalyzerPlugin'
                    })
        
        # Buscar em dados brutos de outros plugins
        self._extract_from_raw_data(context, version_info)
        
        return version_info
    
    def _extract_from_raw_data(self, context: Dict[str, Any], version_info: List[Dict[str, Any]]):
        """Extrai versÃµes de dados brutos de outros plugins"""
        # Patterns para detectar versÃµes em dados brutos
        version_patterns = [
            (r'Apache/(\d+\.\d+\.\d+)', 'Apache'),
            (r'nginx/(\d+\.\d+\.\d+)', 'Nginx'),
            (r'PHP/(\d+\.\d+\.\d+)', 'PHP'),
            (r'OpenSSH[_\s](\d+\.\d+)', 'OpenSSH'),
            (r'OpenSSL[_\s](\d+\.\d+\.\d+)', 'OpenSSL'),
            (r'MySQL[_\s](\d+\.\d+\.\d+)', 'MySQL'),
            (r'PostgreSQL[_\s](\d+\.\d+)', 'PostgreSQL'),
            (r'Microsoft[_\s]IIS[_\s](\d+\.\d+)', 'IIS'),
            (r'Tomcat[_\s](\d+\.\d+\.\d+)', 'Apache Tomcat'),
            (r'jQuery[_\s](\d+\.\d+\.\d+)', 'jQuery'),
            (r'WordPress[_\s](\d+\.\d+\.\d+)', 'WordPress')
        ]
        
        # Buscar em todos os dados do contexto
        # Alguns valores no contexto podem ser objetos datetime; usar default=str para evitar erro
        raw_text = json.dumps(context, default=str).lower()

        for pattern, software_name in version_patterns:
            matches = re.findall(pattern, raw_text, re.IGNORECASE)
            for version in matches:
                # Evitar duplicatas
                if not any(v['name'] == software_name and v['version'] == version for v in version_info):
                    version_info.append({
                        'name': software_name,
                        'version': version,
                        'source': 'raw_data_extraction'
                    })
    
    def _search_exploits_for_software(self, software_name: str, version: str) -> List[Dict[str, Any]]:
        """Busca exploits para um software/versÃ£o especÃ­fico"""
        all_exploits = []
        search_query = f"{software_name} {version}"
        
        # Cache check
        cache_key = f"{software_name}:{version}"
        if cache_key in self.cache:
            return self.cache[cache_key]
        
        # Buscar em ExploitDB
        if self.search_exploitdb:
            exploitdb_results = self._search_exploitdb(search_query, software_name, version)
            all_exploits.extend(exploitdb_results)
        
        # Buscar CVEs
        if self.search_cve:
            cve_results = self._search_cve_database(software_name, version)
            all_exploits.extend(cve_results)
        
        # Buscar no NVD
        if self.search_nvd:
            nvd_results = self._search_nvd_database(software_name, version)
            all_exploits.extend(nvd_results)
        
        # Buscar no GitHub
        if self.search_github:
            github_results = self._search_github_exploits(search_query)
            all_exploits.extend(github_results)
        
        # Cachear resultados
        self.cache[cache_key] = all_exploits
        
        return all_exploits
    
    def _search_exploitdb(self, search_query: str, software: str, version: str) -> List[Dict[str, Any]]:
        """Busca exploits no ExploitDB"""
        exploits = []
        
        try:
            # MÃ©todo 1: Tentar usar searchsploit se disponÃ­vel
            searchsploit_results = self._search_with_searchsploit(search_query)
            if searchsploit_results:
                exploits.extend(searchsploit_results)
            
            # MÃ©todo 2: Busca web scraping (fallback)
            if not exploits:
                web_results = self._search_exploitdb_web(search_query)
                exploits.extend(web_results)
            
        except Exception as e:
            # Adicionar erro aos resultados sem falhar
            exploits.append({
                'title': f'ExploitDB Search Error: {str(e)}',
                'source': 'exploitdb',
                'type': 'error',
                'software': software,
                'version': version
            })
        
        return exploits[:self.max_results_per_source]
    
    def _search_with_searchsploit(self, search_query: str) -> List[Dict[str, Any]]:
        """Usa ferramenta searchsploit se disponÃ­vel"""
        try:
            # Verificar se searchsploit estÃ¡ disponÃ­vel
            result = subprocess.run(['which', 'searchsploit'], capture_output=True, text=True)
            if result.returncode != 0:
                return []
            
            # Executar searchsploit
            cmd = ['searchsploit', '--json', search_query]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0 and result.stdout:
                data = json.loads(result.stdout)
                exploits = []
                
                for exploit in data.get('RESULTS_EXPLOIT', []):
                    exploits.append({
                        'title': exploit.get('Title', ''),
                        'path': exploit.get('Path', ''),
                        'date': exploit.get('Date', ''),
                        'author': exploit.get('Author', ''),
                        'type': exploit.get('Type', ''),
                        'platform': exploit.get('Platform', ''),
                        'source': 'exploitdb_searchsploit',
                        'verified': True,
                        'local_file': True
                    })
                
                return exploits
                
        except (subprocess.TimeoutExpired, json.JSONDecodeError, FileNotFoundError):
            return []
        
        return []
    
    def _search_exploitdb_web(self, search_query: str) -> List[Dict[str, Any]]:
        """Busca exploits via web scraping do ExploitDB"""
        exploits = []
        
        try:
            # Usar API web alternativa ou scraping bÃ¡sico
            search_url = f"https://www.exploit-db.com/search?q={quote(search_query)}"
            
            response = requests.get(search_url, headers=self.headers, timeout=self.timeout)
            
            # Parse bÃ¡sico do HTML (seria melhor usar BeautifulSoup)
            if response.status_code == 200:
                content = response.text
                
                # PadrÃµes bÃ¡sicos para extrair exploits
                exploit_patterns = [
                    r'href="/exploits/(\d+)"[^>]*>([^<]+)</a>',
                    r'data-target="#exploit-(\d+)"[^>]*>([^<]+)<'
                ]
                
                for pattern in exploit_patterns:
                    matches = re.findall(pattern, content)
                    for exploit_id, title in matches[:5]:  # Limitar resultados
                        exploits.append({
                            'id': exploit_id,
                            'title': title.strip(),
                            'url': f"https://www.exploit-db.com/exploits/{exploit_id}",
                            'source': 'exploitdb_web',
                            'verified': False
                        })
            
        except Exception:
            pass  # Falha silenciosa
        
        return exploits
    
    def _search_cve_database(self, software: str, version: str) -> List[Dict[str, Any]]:
        """Busca CVEs relacionadas ao software/versÃ£o"""
        cves = []
        
        try:
            # Buscar usando API CVE.circl.lu
            search_term = f"{software} {version}"
            url = f"{self.cve_api_url}/{quote(search_term)}"
            
            response = requests.get(url, headers=self.headers, timeout=self.timeout)
            
            if response.status_code == 200:
                data = response.json()
                
                # Processar resultados
                for cve_id, cve_data in data.items():
                    if isinstance(cve_data, dict):
                        cvss_score = self._extract_cvss_score(cve_data)
                        
                        if cvss_score >= self.min_cvss_score:
                            cves.append({
                                'cve_id': cve_id,
                                'title': cve_data.get('summary', ''),
                                'cvss_score': cvss_score,
                                'severity': self._cvss_to_severity(cvss_score),
                                'published': cve_data.get('Published', ''),
                                'modified': cve_data.get('Modified', ''),
                                'source': 'cve_circl',
                                'references': cve_data.get('references', []),
                                'cwe': cve_data.get('cwe', ''),
                                'software': software,
                                'version': version
                            })
            
        except Exception as e:
            cves.append({
                'title': f'CVE Search Error: {str(e)}',
                'source': 'cve_database',
                'type': 'error',
                'software': software,
                'version': version
            })
        
        return cves[:self.max_results_per_source]
    
    def _search_nvd_database(self, software: str, version: str) -> List[Dict[str, Any]]:
        """Busca no National Vulnerability Database"""
        nvd_results = []
        
        try:
            # Construir query para NVD API
            keyword = f"{software} {version}"
            params = {
                'keywordSearch': keyword,
                'resultsPerPage': self.max_results_per_source
            }
            
            response = requests.get(
                self.nvd_api_url,
                params=params,
                headers=self.headers,
                timeout=self.timeout
            )
            
            if response.status_code == 200:
                data = response.json()
                vulnerabilities = data.get('vulnerabilities', [])
                
                for vuln in vulnerabilities:
                    cve_data = vuln.get('cve', {})
                    cve_id = cve_data.get('id', '')
                    
                    # Extrair CVSS score
                    cvss_score = 0.0
                    metrics = cve_data.get('metrics', {})
                    if 'cvssMetricV3' in metrics:
                        cvss_data = metrics['cvssMetricV3'][0].get('cvssData', {})
                        cvss_score = cvss_data.get('baseScore', 0.0)
                    elif 'cvssMetricV2' in metrics:
                        cvss_data = metrics['cvssMetricV2'][0].get('cvssData', {})
                        cvss_score = cvss_data.get('baseScore', 0.0)
                    
                    if cvss_score >= self.min_cvss_score:
                        descriptions = cve_data.get('descriptions', [])
                        description = ''
                        for desc in descriptions:
                            if desc.get('lang') == 'en':
                                description = desc.get('value', '')
                                break
                        
                        nvd_results.append({
                            'cve_id': cve_id,
                            'title': description[:100] + '...' if len(description) > 100 else description,
                            'description': description,
                            'cvss_score': cvss_score,
                            'severity': self._cvss_to_severity(cvss_score),
                            'published': cve_data.get('published', ''),
                            'modified': cve_data.get('lastModified', ''),
                            'source': 'nvd',
                            'software': software,
                            'version': version
                        })
            
        except Exception as e:
            nvd_results.append({
                'title': f'NVD Search Error: {str(e)}',
                'source': 'nvd',
                'type': 'error',
                'software': software,
                'version': version
            })
        
        return nvd_results
    
    def _search_github_exploits(self, search_query: str) -> List[Dict[str, Any]]:
        """Busca exploits pÃºblicos no GitHub"""
        github_results = []
        
        try:
            # Buscar repositÃ³rios com exploits
            search_terms = [
                f"{search_query} exploit",
                f"{search_query} vulnerability",
                f"{search_query} PoC"
            ]
            
            for term in search_terms[:2]:  # Limitar buscas
                url = "https://api.github.com/search/repositories"
                params = {
                    'q': term,
                    'sort': 'updated',
                    'per_page': 5  # Poucos resultados por busca
                }
                
                response = requests.get(url, params=params, headers=self.headers, timeout=self.timeout)
                
                if response.status_code == 200:
                    data = response.json()
                    
                    for repo in data.get('items', []):
                        github_results.append({
                            'title': repo.get('name', ''),
                            'description': repo.get('description', ''),
                            'url': repo.get('html_url', ''),
                            'stars': repo.get('stargazers_count', 0),
                            'updated': repo.get('updated_at', ''),
                            'language': repo.get('language', ''),
                            'source': 'github',
                            'type': 'repository'
                        })
                
                # Rate limiting
                time.sleep(1)
            
        except Exception as e:
            github_results.append({
                'title': f'GitHub Search Error: {str(e)}',
                'source': 'github',
                'type': 'error'
            })
        
        return github_results[:5]  # Limitar resultados finais
    
    def _extract_cvss_score(self, cve_data: Dict[str, Any]) -> float:
        """Extrai score CVSS de dados de CVE"""
        try:
            # Tentar diferentes formatos de CVSS
            if 'cvss' in cve_data:
                return float(cve_data['cvss'])
            
            if 'cvss-score' in cve_data:
                return float(cve_data['cvss-score'])
            
            if 'baseScore' in cve_data:
                return float(cve_data['baseScore'])
            
            return 0.0
            
        except (ValueError, TypeError):
            return 0.0
    
    def _cvss_to_severity(self, cvss_score: float) -> str:
        """Converte score CVSS para nÃ­vel de severidade"""
        if cvss_score >= 9.0:
            return 'CRITICAL'
        elif cvss_score >= 7.0:
            return 'HIGH'
        elif cvss_score >= 4.0:
            return 'MEDIUM'
        elif cvss_score > 0.0:
            return 'LOW'
        else:
            return 'UNKNOWN'
    
    def _classify_exploits(self, exploits: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """Classifica exploits por severidade"""
        classified = {
            'CRITICAL': [],
            'HIGH': [],
            'MEDIUM': [],
            'LOW': [],
            'UNKNOWN': [],
            'REPOSITORIES': [],
            'ERRORS': []
        }
        
        for exploit in exploits:
            if exploit.get('type') == 'error':
                classified['ERRORS'].append(exploit)
            elif exploit.get('source') == 'github':
                classified['REPOSITORIES'].append(exploit)
            else:
                severity = exploit.get('severity', 'UNKNOWN')
                classified[severity].append(exploit)
        
        return classified
    
    def _generate_exploit_report(self, classified_exploits: Dict[str, List], search_results: Dict[str, Any]) -> Dict[str, Any]:
        """Gera relatÃ³rio resumido de exploits"""
        total_critical = len(classified_exploits.get('CRITICAL', []))
        total_high = len(classified_exploits.get('HIGH', []))
        total_medium = len(classified_exploits.get('MEDIUM', []))
        total_low = len(classified_exploits.get('LOW', []))
        
        # Calcular risk score
        risk_score = (total_critical * 10) + (total_high * 7) + (total_medium * 4) + (total_low * 2)
        
        # Determinar nÃ­vel de risco geral
        if total_critical > 0:
            risk_level = 'CRITICAL'
        elif total_high > 0:
            risk_level = 'HIGH'
        elif total_medium > 0:
            risk_level = 'MEDIUM'
        elif total_low > 0:
            risk_level = 'LOW'
        else:
            risk_level = 'MINIMAL'
        
        # Top exploits mais crÃ­ticos
        top_exploits = []
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM']:
            exploits = classified_exploits.get(severity, [])
            for exploit in exploits[:3]:  # Top 3 de cada categoria
                top_exploits.append(exploit)
        
        recommendations = self._generate_recommendations(classified_exploits)
        
        return {
            'risk_assessment': {
                'overall_risk_level': risk_level,
                'risk_score': risk_score,
                'critical_vulnerabilities': total_critical,
                'high_vulnerabilities': total_high,
                'medium_vulnerabilities': total_medium,
                'low_vulnerabilities': total_low
            },
            'top_threats': top_exploits,
            'recommendations': recommendations,
            'sources_searched': self._get_active_sources(),
            'search_statistics': {
                'total_software_analyzed': len(search_results),
                'software_with_exploits': len([k for k, v in search_results.items() if v])
            }
        }
    
    def _generate_recommendations(self, classified_exploits: Dict[str, List]) -> List[str]:
        """Gera recomendaÃ§Ãµes baseadas nos exploits encontrados"""
        recommendations = []
        
        if classified_exploits.get('CRITICAL'):
            recommendations.append("ðŸš¨ AÃ‡ÃƒO IMEDIATA: Vulnerabilidades crÃ­ticas detectadas. Aplicar patches urgentemente.")
        
        if classified_exploits.get('HIGH'):
            recommendations.append("âš ï¸ ALTA PRIORIDADE: Atualizar software com vulnerabilidades de alto risco.")
        
        if classified_exploits.get('MEDIUM'):
            recommendations.append("ðŸ“‹ PLANEJADO: Incluir correÃ§Ãµes de vulnerabilidades mÃ©dias no prÃ³ximo ciclo de atualizaÃ§Ãµes.")
        
        if len(classified_exploits.get('REPOSITORIES', [])) > 0:
            recommendations.append("ðŸ” MONITORAMENTO: Exploits pÃºblicos disponÃ­veis. Monitorar tentativas de ataque.")
        
        # RecomendaÃ§Ãµes gerais
        recommendations.extend([
            "ðŸ”’ Implementar Web Application Firewall (WAF) se aplicÃ¡vel",
            "ðŸ“Š Estabelecer monitoramento contÃ­nuo de vulnerabilidades",
            "ðŸ›¡ï¸ Realizar testes de penetraÃ§Ã£o regulares",
            "ðŸ“ Manter inventÃ¡rio atualizado de software e versÃµes"
        ])
        
        return recommendations
    
    def _get_active_sources(self) -> List[str]:
        """Retorna lista de fontes ativas na busca"""
        sources = []
        if self.search_exploitdb:
            sources.append('ExploitDB')
        if self.search_cve:
            sources.append('CVE Database')
        if self.search_nvd:
            sources.append('NVD')
        if self.search_github:
            sources.append('GitHub')
        return sources
    
    def _generate_search_summary(self, version_info: List[Dict], all_exploits: List[Dict]) -> Dict[str, Any]:
        """Gera resumo da busca realizada"""
        return {
            'software_analyzed': [
                f"{info.get('name', 'unknown')} {info.get('version', 'unknown')}"
                for info in version_info
            ],
            'total_exploits_found': len(all_exploits),
            'sources_with_results': list(set(
                exploit.get('source', 'unknown') 
                for exploit in all_exploits 
                if exploit.get('source')
            )),
            'search_duration': 'Included in execution_time',
            'cache_hits': len(self.cache)
        }
