#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Orquestrador de Pentest - Orquestra o fluxo:
1) Resolução DNS
2) Scan de Portas
3) Decisão IA
4) (Opcional) Nmap Avançado

Responsabilidades auxiliares (persistência e relatórios) foram extraídas para:
- infra/persistencia.py
- relatorios/gerador_html.py
- utils/rede.py (IP/extração)
- utils/resumo.py (consolidação de resumos)
"""

from datetime import datetime
from typing import Dict, Any, List

from utils.logger import obter_logger, log_manager
from utils.rede import extrair_ips_para_scan
from utils.resumo import gerar_resumo_scan_completo, gerar_resumo_nmap_avancado


class OrquestradorPentest:
    """Orquestrador de Pentest - DNS + Scan de Portas"""

    def __init__(self, resolver_dns, scanner_portas, scanner_nmap, decisao_ia, logger_func=obter_logger):
        """Inicializa o orquestrador"""
        self.logger = logger_func('OrquestradorPentest')
        self.resolver_dns = resolver_dns
        self.scanner_portas = scanner_portas
        self.scanner_nmap = scanner_nmap
        self.decisao_ia = decisao_ia

        self.logger.info("Orquestrador Pentest inicializado")

    def executar_pentest_inicial(self, alvo: str) -> Dict[str, Any]:
        """
        Executa pentest inicial: DNS + Scan de Portas
        Args:
            alvo (str): Alvo (domínio ou IP) para analisar
        Returns:
            Dict[str, Any]: Resultados completos
        """
        self.logger.info(f"Iniciando pentest inicial para {alvo}")

        resultado_completo: Dict[str, Any] = {
            'timestamp_inicio': datetime.now().isoformat(),
            'alvo_original': alvo,
            'fase': 'pentest_inicial',
            'resolucao_dns': {},
            'scan_portas': {},
            'sucesso_geral': False
        }

        try:
            # 1) Resolução DNS
            self.logger.info("=== Resolução DNS ===")
            resultado_dns = self.resolver_dns.resolver_dns(alvo)
            resultado_completo['resolucao_dns'] = resultado_dns

            if not resultado_dns.get('sucesso'):
                self.logger.error(f"Falha na resolução DNS: {resultado_dns.get('erro')}")
                resultado_completo['erro'] = f"Falha na resolução DNS: {resultado_dns.get('erro')}"
                return resultado_completo

            self.logger.info("Resolução DNS concluída com sucesso")

            # 2) Obter IPs para scan
            ips_para_scan = extrair_ips_para_scan(resultado_dns)

            if not ips_para_scan:
                self.logger.error("Nenhum IP encontrado para scan de portas")
                resultado_completo['erro'] = "Nenhum IP encontrado para scan de portas"
                return resultado_completo

            # 3) Scan de Portas
            self.logger.info("=== Scan de Portas ===")
            resultados_scan: Dict[str, Any] = {}

            for ip in ips_para_scan:
                self.logger.info(f"Executando scan de portas em {ip}")
                resultado_scan = self.scanner_portas.varredura_completa(ip)
                resultados_scan[ip] = resultado_scan

                if resultado_scan.get('sucesso'):
                    resumo_scan = self.scanner_portas.gerar_resumo(resultado_scan)
                    self.logger.info(f"Scan concluído em {ip}: {resumo_scan.get('portas_abertas', 0)} portas abertas")
                else:
                    self.logger.warning(f"Falha no scan de {ip}: {resultado_scan.get('erro')}")

            resultado_completo['scan_portas'] = resultados_scan
            resultado_completo['sucesso_geral'] = True
            resultado_completo['timestamp_fim'] = datetime.now().isoformat()

            # 4) Gerar resumos
            resumo_dns = self.resolver_dns.gerar_resumo(resultado_dns)
            resultado_completo['resumo_dns'] = resumo_dns

            resumo_scan = gerar_resumo_scan_completo(resultados_scan, self.scanner_portas)
            resultado_completo['resumo_scan'] = resumo_scan

            # 5) Decisão IA para próximos passos
            self.logger.info("=== Análise IA e Decisão ===")
            decisao_ia = self.decisao_ia.decidir_proximos_passos(resultado_completo)
            resultado_completo['decisao_ia'] = decisao_ia

            # 6) Executar Nmap avançado se recomendado
            if decisao_ia.get('executar_nmap_avancado', False):
                self.logger.info("=== Execução Nmap Avançado ===")
                resultados_nmap_avancado = self._executar_nmap_avancado(
                    ips_para_scan,
                    decisao_ia.get('modulos_recomendados', []),
                    decisao_ia.get('portas_prioritarias', [])
                )
                resultado_completo['nmap_avancado'] = resultados_nmap_avancado
            else:
                self.logger.info("IA decidiu não executar Nmap avançado")
                resultado_completo['nmap_avancado'] = {
                    'executado': False,
                    'motivo': decisao_ia.get('justificativa_ia', 'IA não recomendou análise adicional')
                }

            # 7) Log da sessão
            log_manager.log_sessao_pentest('pentest_inicial', {
                'alvo': alvo,
                'tipo_alvo': resultado_dns.get('tipo_alvo', 'desconhecido'),
                'ips_scaneados': len(ips_para_scan),
                'total_portas_abertas': resumo_scan.get('total_portas_abertas', 0),
                'hosts_ativos': resumo_scan.get('hosts_ativos', 0),
                'ia_recomendou_nmap': decisao_ia.get('executar_nmap_avancado', False),
                'modulos_ia_recomendados': len(decisao_ia.get('modulos_recomendados', []))
            })

            return resultado_completo

        except Exception as e:
            self.logger.error(f"Erro na execução: {str(e)}")
            resultado_completo['erro'] = f'Erro na execução: {str(e)}'
            resultado_completo['timestamp_fim'] = datetime.now().isoformat()
            return resultado_completo

    def _executar_nmap_avancado(self, ips: List[str], modulos_recomendados: List[str],
                                portas_prioritarias: List[str]) -> Dict[str, Any]:
        """
        Executa varreduras Nmap avançadas baseadas na recomendação da IA
        Args:
            ips (List[str]): Lista de IPs para varredura
            modulos_recomendados (List[str]): Módulos recomendados pela IA
            portas_prioritarias (List[str]): Portas prioritárias para análise
        Returns:
            Dict[str, Any]: Resultados das varreduras avançadas
        """
        resultados_nmap: Dict[str, Any] = {
            'timestamp_inicio': datetime.now().isoformat(),
            'ips_analisados': ips,
            'modulos_executados': [],
            'resultados_por_modulo': {},
            'resumo_geral': {},
            'sucesso_geral': False
        }

        try:
            # Mapear nomes de módulos para métodos
            mapa_modulos = {
                'varredura_basica': self.scanner_nmap.varredura_basica,
                'varredura_completa': self.scanner_nmap.varredura_completa,
                'varredura_vulnerabilidades': self.scanner_nmap.varredura_vulnerabilidades,
                'varredura_servicos_web': self.scanner_nmap.varredura_servicos_web,
                'varredura_smb': self.scanner_nmap.varredura_smb,
                'varredura_descoberta_rede': self.scanner_nmap.varredura_descoberta_rede
            }

            # Preparar portas para varredura
            portas_str = ','.join(map(str, portas_prioritarias)) if portas_prioritarias else None

            # Executar cada módulo recomendado
            for modulo in modulos_recomendados:
                if modulo in mapa_modulos:
                    self.logger.info(f"Executando módulo: {modulo}")

                    resultados_modulo: Dict[str, Any] = {}

                    # Executar para cada IP
                    for ip in ips:
                        try:
                            if modulo == 'varredura_descoberta_rede':
                                # Para descoberta de rede, usar notação CIDR
                                rede = f"{'.'.join(ip.split('.')[:-1])}.0/24"
                                resultado = mapa_modulos[modulo](rede)
                            else:
                                # Para outros módulos, usar IP específico
                                if modulo in ['varredura_basica', 'varredura_completa', 'varredura_vulnerabilidades']:
                                    # Usar retry automático para varreduras que podem ter timeout
                                    resultado = self.scanner_nmap.executar_varredura_com_retry(
                                        mapa_modulos[modulo], ip, max_tentativas=2, portas=portas_str
                                    )
                                else:
                                    resultado = self.scanner_nmap.executar_varredura_com_retry(
                                        mapa_modulos[modulo], ip, max_tentativas=2
                                    )

                            resultados_modulo[ip] = resultado

                            if resultado.get('sucesso'):
                                self.logger.info(f"Módulo {modulo} executado com sucesso em {ip}")
                            else:
                                self.logger.warning(f"Falha no módulo {modulo} em {ip}: {resultado.get('erro')}")
                                
                                # Diagnosticar problemas de timeout
                                if 'timeout' in resultado.get('erro', '').lower():
                                    diagnostico = self.scanner_nmap.diagnosticar_timeout(resultado)
                                    self.logger.info(f"Diagnóstico de timeout para {modulo}:")
                                    for sugestao in diagnostico.get('sugestoes', [])[:2]:
                                        self.logger.info(f"  - {sugestao}")

                        except Exception as e:
                            self.logger.error(f"Erro ao executar {modulo} em {ip}: {str(e)}")
                            resultados_modulo[ip] = {
                                'sucesso': False,
                                'erro': f'Erro na execução: {str(e)}',
                                'timestamp': datetime.now().isoformat()
                            }

                    resultados_nmap['resultados_por_modulo'][modulo] = resultados_modulo
                    resultados_nmap['modulos_executados'].append(modulo)

                else:
                    self.logger.warning(f"Módulo desconhecido: {modulo}")

            # Gerar resumo geral agregado
            resultados_nmap['resumo_geral'] = gerar_resumo_nmap_avancado(resultados_nmap)
            resultados_nmap['sucesso_geral'] = len(resultados_nmap['modulos_executados']) > 0
            resultados_nmap['timestamp_fim'] = datetime.now().isoformat()

            self.logger.info(f"Nmap avançado concluído: {len(resultados_nmap['modulos_executados'])} módulos executados")

        except Exception as e:
            self.logger.error(f"Erro na execução do Nmap avançado: {str(e)}")
            resultados_nmap['erro'] = f'Erro na execução: {str(e)}'
            resultados_nmap['timestamp_fim'] = datetime.now().isoformat()

        # Marcar execução quando houve tentativa
        resultados_nmap.setdefault('executado', True)
        return resultados_nmap